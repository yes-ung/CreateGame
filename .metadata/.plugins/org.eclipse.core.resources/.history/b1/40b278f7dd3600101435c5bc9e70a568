import java.awt.Color;
import java.awt.Graphics;
import java.awt.image.BufferedImage;
import java.util.List;

public class UnitEnemy extends Unit {
	

	public UnitEnemy(double x, double y,Team team) {
		super(x, y,team);
		// TODO Auto-generated constructor stub
	}
	
	   @Override
	  public void update(List<Unit> allUnits) {
	    	if (isDead) return;
	    	
	    	// 타겟이 없거나 죽었으면 다시 찾기
	        if (targetEnemy == null || targetEnemy.isDead) {
	            targetEnemy = findNearestEnemy(allUnits);
	        }  	
	    	attackTimer++; // 공격 쿨타임
	    	// 공격 처리
	        if (targetEnemy != null && !targetEnemy.isDead) {
	            double dx = targetEnemy.x - this.x;
	            double dy = targetEnemy.y - this.y;
	            double distance = Math.sqrt(dx * dx + dy * dy);

	            if (distance <= attackRange) {
	                if (attackTimer >= attackCooldown) {
	                    attackEnemy();
	                    attackTimer = 0;
	                }
	                // return;공격 중엔 이동하지 않음
	                
	            } else {
	            	// 타겟에게 다가감
	                setTarget(targetEnemy.x, targetEnemy.y);
	            }
	        }
	    	//목적지 근처 도착했으면 안움직이게 하기
	    	if (hasArrived) return; 
	        double dx = targetX - x;
	        double dy = targetY -  y;
	        double distance = Math.sqrt(dx * dx + dy * dy);

	        if (distance > speed) {
	            x += speed * dx / distance;
	            y += speed * dy / distance;

	            // 방향 업데이트
	            direction = getDirectionFromDelta(dx, dy);

	            // 애니메이션 프레임 전환
	            frameTimer++;
	            if (frameTimer >= frameDelay) {
	                frameTimer = 0;
	                currentFrame = (currentFrame + 1) % frameCount;
	            }
	        } else {
	            x = targetX;
	            y = targetY;
	            currentFrame = 0; 
	            //        	도착시 달달 떨리는거 없애는 용도
	        }
	        
	        for (Unit other : allUnits) {
	            if (other != this && isColliding(other)&&distance<30) {
	                hasArrived = true;
	                return;
	            }
	        } // 도착지점 근처이며 유닛과 충돌했을경우 도착지점까지 도달안해도 완료된걸로 보고 멈추기 
	               
	    }    


	@Override
	public void draw(Graphics g) {
		if (isDead)
			return; // 죽었으면 안그리기,사라지기
		int dirIndex = direction.ordinal();
		BufferedImage frame = directionFrames[dirIndex][currentFrame];
		int drawX = (int) x;
		int drawY = (int) y + 70;

		if (frame != null) {
			g.drawImage(frame, (int) x - frame.getWidth() / 2, (int) y - frame.getHeight() / 2, null);
		} else {
			g.setColor(Color.GREEN);
			g.fillOval((int) x - 10, (int) y - 10, 20, 20);
		}
		// 체력바 그리기
		int barWidth = 50;
		int hpWidth = (int) ((currentHP / (double) maxHP) * barWidth);
//        g.setColor(Color.RED);
//        g.fillRect(drawX - barWidth/2, drawY, barWidth, 5);

		g.setColor(Color.red);
		g.fillRect(drawX - barWidth / 2, drawY, hpWidth, 5);
		g.setColor(Color.BLACK);
		g.drawRect(drawX - barWidth / 2, drawY, barWidth, 5);

	}
}
